---
title: "Eure-et-Loir"
region: "Eure-et-loir"
params:
  year: 1982
  suffix: "h"
format: html
jupyter: cartoscope-venv
---

```{python}
import pandas as pd
import json
import pathlib
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np

# Configuration
REGION_SLUG = 'eure-et-loir'
DATA_DIR = pathlib.Path('../../static/data')

# Chargement des donn√©es
series_path = DATA_DIR / f'{REGION_SLUG}-series.json'
aggregates_path = DATA_DIR / f'{REGION_SLUG}-aggregates.json'
quality_path = DATA_DIR / f'{REGION_SLUG}-quality-report.json'

print("üìä Chargement des donn√©es pour visualisation...")
```

```{python}

```
# Eure-et-Loir : Exploration d√©mographique et cartographique

L'**Eure-et-Loir** offre un terrain d'√©tude fascinant pour comprendre l'√©volution d√©mographique et administrative fran√ßaise sur pr√®s de huit si√®cles.

## Aper√ßu des donn√©es

```{python}
# Chargement du rapport de qualit√©
with open(quality_path, 'r', encoding='utf-8') as f:
    quality_report = json.load(f)

print(f"üìã Donn√©es trait√©es :")
print(f"   ‚Ä¢ {quality_report['total_communes']} communes")
print(f"   ‚Ä¢ {quality_report['series_records_generated']:,} points de donn√©es")
print(f"   ‚Ä¢ P√©riode : {quality_report['year_range']}")
print(f"   ‚Ä¢ {len(quality_report['suffixes_available'])} types de mesures")
```

Cette r√©gion pr√©sente des donn√©es exceptionnellement riches avec **489 communes** r√©pertori√©es, couvrant **732 ann√©es** d'histoire d√©mographique et administrative.

## √âvolution d√©mographique r√©gionale

```{python}
# Chargement des agr√©gats pour graphiques
with open(aggregates_path, 'r', encoding='utf-8') as f:
    aggregates = pd.DataFrame(json.load(f))

# Graphique d'√©volution pour les habitants
habitants_data = aggregates[aggregates['suffix'] == 'h'].copy()
habitants_data = habitants_data.sort_values('year')

if not habitants_data.empty:
    fig_evolution = px.line(
        habitants_data, 
        x='year', 
        y='value_sum',
        title='√âvolution de la population totale (habitants)',
        labels={
            'year': 'Ann√©e',
            'value_sum': 'Population totale',
            'value_count': 'Nombre de communes'
        },
        hover_data=['value_count']
    )
    
    fig_evolution.update_layout(
        xaxis_title="Ann√©e",
        yaxis_title="Population totale",
        hovermode='x unified',
        template='plotly_white'
    )
    
    fig_evolution.update_traces(
        line=dict(width=3, color='#3498db'),
        hovertemplate='<b>%{x}</b><br>Population: %{y:,}<br>Communes: %{customdata[0]}<extra></extra>'
    )
    
    fig_evolution.show()
else:
    print("‚ö†Ô∏è Pas de donn√©es 'habitants' pour le graphique d'√©volution")
```

### Analyse par type de mesure

```{python}
# Graphique de comparaison par suffixe
fig_suffixes = make_subplots(
    rows=2, cols=2,
    subplot_titles=['Habitants (h)', 'Feux (f)', 'Total (f_tot)', 'Masculin (f_masc)'],
    vertical_spacing=0.1
)

suffixes_to_plot = ['h', 'f', 'f_tot', 'f_masc']
positions = [(1,1), (1,2), (2,1), (2,2)]

for i, suffix in enumerate(suffixes_to_plot):
    data_suffix = aggregates[aggregates['suffix'] == suffix].copy()
    data_suffix = data_suffix.sort_values('year')
    
    if not data_suffix.empty:
        row, col = positions[i]
        fig_suffixes.add_trace(
            go.Scatter(
                x=data_suffix['year'],
                y=data_suffix['value_sum'],
                mode='lines+markers',
                name=suffix,
                line=dict(width=2),
                marker=dict(size=4)
            ),
            row=row, col=col
        )

fig_suffixes.update_layout(
    title_text="√âvolution par type de mesure",
    showlegend=False,
    template='plotly_white',
    height=600
)

fig_suffixes.update_xaxes(title_text="Ann√©e")
fig_suffixes.update_yaxes(title_text="Total r√©gional")

fig_suffixes.show()
```

### Distribution des donn√©es par p√©riode

```{python}
# Analyse de la compl√©tude temporelle
with open(series_path, 'r', encoding='utf-8') as f:
    series_data = pd.DataFrame(json.load(f))

# Compl√©tude par d√©cennie
series_data['decade'] = (series_data['year'] // 10) * 10
completeness_by_decade = series_data.groupby(['decade', 'suffix']).size().reset_index(name='count')

# Focus sur les habitants
h_completeness = completeness_by_decade[completeness_by_decade['suffix'] == 'h']

if not h_completeness.empty:
    fig_completeness = px.bar(
        h_completeness,
        x='decade',
        y='count',
        title='Disponibilit√© des donn√©es "habitants" par d√©cennie',
        labels={'decade': 'D√©cennie', 'count': 'Nombre de communes avec donn√©es'}
    )
    
    fig_completeness.update_layout(
        xaxis_title="D√©cennie",
        yaxis_title="Communes avec donn√©es",
        template='plotly_white'
    )
    
    fig_completeness.update_traces(marker_color='#2ecc71')
    fig_completeness.show()
```

## √âvolution administrative

### Ancien R√©gime
Les donn√©es r√©v√®lent la complexit√© du syst√®me administratif d'Ancien R√©gime avec ses multiples √©chelons :

- **Intendances** : Paris, Orl√©ans, Alen√ßon
- **Dioc√®ses** : Chartres principalement  
- **Bailliages, √©lections, greniers √† sel** : maillage territorial dense

### R√©volution et √©poque moderne
La R√©volution fran√ßaise a profond√©ment restructur√© l'organisation territoriale :

- **Districts de 1790** : premi√®re r√©organisation r√©volutionnaire
- **Cantons** : √©volution de 1790 √† 1982
- **Arrondissements modernes** : d√©coupage contemporain

## Qualit√© et compl√©tude des donn√©es

```{python}
# Statistiques de qualit√©
completeness_stats = pd.DataFrame(list(quality_report['completeness_by_suffix'].items()), 
                                 columns=['suffix', 'completeness_pct'])
completeness_stats = completeness_stats.sort_values('completeness_pct', ascending=True)

fig_quality = px.bar(
    completeness_stats,
    y='suffix',
    x='completeness_pct',
    orientation='h',
    title='Compl√©tude des donn√©es par type de mesure (%)',
    labels={'suffix': 'Type de mesure', 'completeness_pct': 'Compl√©tude (%)'}
)

fig_quality.update_layout(
    xaxis_title="Compl√©tude (%)",
    yaxis_title="Type de mesure",
    template='plotly_white'
)

fig_quality.update_traces(marker_color='#e74c3c')
fig_quality.show()

print(f"\nüìä R√©sum√© qualit√© :")
print(f"   ‚Ä¢ {quality_report['uncertainty_flags']} communes avec flags d'incertitude")
print(f"   ‚Ä¢ {quality_report['communes_with_series']}/{quality_report['total_communes']} communes avec donn√©es temporelles")
print(f"   ‚Ä¢ 0/{quality_report['total_communes']} communes avec coordonn√©es g√©ographiques")
```

### Types de mesures disponibles

- **h** : Habitants (population totale)
- **f** : Feux (unit√©s fiscales d'Ancien R√©gime)  
- **f_tot, f_masc** : D√©compositions par genre
- **g** : Mesures sp√©cifiques (√† pr√©ciser)

## Utilisation de la carte

La carte interactive permet d'explorer ces donn√©es :

1. **Naviguez dans le temps** avec le slider (1250-1982)
2. **Changez le type de mesure** avec le s√©lecteur
3. **Explorez les d√©tails** en cliquant sur les communes
4. **Partagez** une vue sp√©cifique via l'URL

---

**Note technique** : Les coordonn√©es g√©ographiques ne sont pas encore int√©gr√©es. La carte montre actuellement la structure des donn√©es mais les marqueurs ne sont pas g√©olocalis√©s. Cette fonctionnalit√© sera ajout√©e dans une prochaine version.

## Perspectives d'analyse

Ces donn√©es permettent d'√©tudier :

- L'impact des crises d√©mographiques (guerres, famines, √©pid√©mies)
- Les transformations administratives et leur effet sur les territoires
- L'√©volution des syst√®mes de mesure et de recensement
- Les dynamiques territoriales √† long terme
